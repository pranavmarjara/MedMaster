"""
VibeyBot Diagnostic Reasoning Engine
Advanced neural network for medical diagnosis generation and clinical reasoning
Integrated with the main VibeyBot intelligence system
"""
import torch
import torch.nn as nn
import torch.nn.functional as F
from transformers import GPT2LMHeadModel, GPT2Tokenizer, AutoTokenizer, AutoModel
import numpy as np
from typing import Dict, List, Tuple, Optional, Union
import logging
import json
import os
from datetime import datetime
import re
from dataclasses import dataclass

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class DiagnosticHypothesis:
    """Data class for diagnostic hypotheses generated by VibeyBot"""
    condition: str
    confidence_score: float
    supporting_evidence: List[str]
    risk_factors: List[str]
    recommended_tests: List[str]
    urgency_level: str
    differential_rank: int

class VibeyDiagnosticReasoningEngine(nn.Module):
    """
    Advanced diagnostic reasoning model for VibeyBot medical AI system
    Generates ranked differential diagnoses with supporting evidence
    """
    
    def __init__(self, 
                 base_model: str = "microsoft/DialoGPT-medium",
                 medical_vocab_size: int = 50000,
                 reasoning_layers: int = 12,
                 attention_heads: int = 16,
                 embedding_dim: int = 768):
        super(VibeyDiagnosticReasoningEngine, self).__init__()
        
        self.base_model_name = base_model
        self.medical_vocab_size = medical_vocab_size
        self.reasoning_layers = reasoning_layers
        self.attention_heads = attention_heads
        self.embedding_dim = embedding_dim
        
        # Initialize medical language model
        self.tokenizer = GPT2Tokenizer.from_pretrained(base_model)
        self.language_model = GPT2LMHeadModel.from_pretrained(base_model)
        
        # Add special medical tokens
        special_tokens = [
            "<SYMPTOM>", "<DIAGNOSIS>", "<TREATMENT>", "<LAB_VALUE>",
            "<VITAL_SIGN>", "<MEDICATION>", "<PROCEDURE>", "<RISK_FACTOR>",
            "<EVIDENCE>", "<DIFFERENTIAL>", "<URGENCY>", "<CONFIDENCE>"
        ]
        self.tokenizer.add_special_tokens({'additional_special_tokens': special_tokens})
        self.language_model.resize_token_embeddings(len(self.tokenizer))
        
        # Medical knowledge graph embeddings
        self.medical_knowledge_embedder = nn.Embedding(
            num_embeddings=10000,  # Medical concepts
            embedding_dim=embedding_dim
        )
        
        # Clinical reasoning transformer
        self.reasoning_transformer = nn.TransformerEncoder(
            nn.TransformerEncoderLayer(
                d_model=embedding_dim,
                nhead=attention_heads,
                dim_feedforward=embedding_dim * 4,
                dropout=0.1,
                activation='gelu'
            ),
            num_layers=reasoning_layers
        )
        
        # Diagnostic confidence scorer
        self.confidence_scorer = nn.Sequential(
            nn.Linear(embedding_dim * 2, embedding_dim),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(embedding_dim, embedding_dim // 2),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(embedding_dim // 2, 1),
            nn.Sigmoid()
        )
        
        # Evidence strength classifier
        self.evidence_classifier = nn.Sequential(
            nn.Linear(embedding_dim, embedding_dim // 2),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(embedding_dim // 2, 4)  # strong, moderate, weak, contradictory
        )
        
        # Medical condition encoder
        self.condition_encoder = nn.Linear(embedding_dim, embedding_dim)
        
        # Risk stratification network
        self.risk_stratifier = nn.Sequential(
            nn.Linear(embedding_dim, embedding_dim // 2),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(embedding_dim // 2, 5)  # critical, high, medium, low, minimal
        )
        
        # Load medical knowledge base
        self.medical_conditions = self._load_medical_conditions()
        self.symptom_mappings = self._load_symptom_mappings()
        self.diagnostic_criteria = self._load_diagnostic_criteria()
        
    def _load_medical_conditions(self) -> Dict[str, Dict]:
        """Load comprehensive medical conditions database"""
        return {
            "myocardial_infarction": {
                "category": "cardiovascular",
                "severity": "critical",
                "icd10": "I21",
                "key_symptoms": ["chest pain", "dyspnea", "diaphoresis", "nausea"],
                "key_labs": ["troponin", "ck-mb", "ldh"],
                "red_flags": ["st elevation", "cardiogenic shock", "arrhythmia"]
            },
            "diabetes_mellitus_type2": {
                "category": "endocrine",
                "severity": "chronic",
                "icd10": "E11",
                "key_symptoms": ["polyuria", "polydipsia", "polyphagia", "weight loss"],
                "key_labs": ["hba1c", "fasting glucose", "random glucose"],
                "red_flags": ["dka", "hhs", "severe hypoglycemia"]
            },
            "pneumonia": {
                "category": "respiratory",
                "severity": "moderate",
                "icd10": "J18",
                "key_symptoms": ["cough", "fever", "dyspnea", "chest pain"],
                "key_labs": ["wbc", "crp", "procalcitonin"],
                "red_flags": ["sepsis", "respiratory failure", "empyema"]
            },
            "hypertension": {
                "category": "cardiovascular",
                "severity": "chronic",
                "icd10": "I10",
                "key_symptoms": ["headache", "dizziness", "blurred vision"],
                "key_labs": ["electrolytes", "creatinine", "urinalysis"],
                "red_flags": ["hypertensive crisis", "target organ damage"]
            },
            "acute_appendicitis": {
                "category": "gastrointestinal",
                "severity": "urgent",
                "icd10": "K35",
                "key_symptoms": ["abdominal pain", "nausea", "vomiting", "fever"],
                "key_labs": ["wbc", "crp"],
                "red_flags": ["perforation", "peritonitis", "sepsis"]
            },
            "chronic_kidney_disease": {
                "category": "renal",
                "severity": "chronic",
                "icd10": "N18",
                "key_symptoms": ["fatigue", "edema", "decreased urination"],
                "key_labs": ["creatinine", "bun", "egfr", "proteinuria"],
                "red_flags": ["acute on chronic", "hyperkalemia", "pulmonary edema"]
            },
            "depression": {
                "category": "psychiatric",
                "severity": "moderate",
                "icd10": "F32",
                "key_symptoms": ["depressed mood", "anhedonia", "sleep disturbance"],
                "key_labs": ["tsh", "b12", "folate"],
                "red_flags": ["suicidal ideation", "psychotic features"]
            },
            "copd_exacerbation": {
                "category": "respiratory",
                "severity": "moderate",
                "icd10": "J44.1",
                "key_symptoms": ["dyspnea", "cough", "sputum production"],
                "key_labs": ["abg", "wbc", "crp"],
                "red_flags": ["respiratory failure", "cor pulmonale"]
            }
        }
    
    def _load_symptom_mappings(self) -> Dict[str, List[str]]:
        """Load symptom to condition mappings"""
        return {
            "chest_pain": ["myocardial_infarction", "pneumonia", "pulmonary_embolism"],
            "dyspnea": ["myocardial_infarction", "pneumonia", "copd_exacerbation"],
            "abdominal_pain": ["acute_appendicitis", "cholecystitis", "bowel_obstruction"],
            "fever": ["pneumonia", "uti", "sepsis", "acute_appendicitis"],
            "fatigue": ["depression", "chronic_kidney_disease", "anemia"],
            "headache": ["hypertension", "migraine", "intracranial_pressure"]
        }
    
    def _load_diagnostic_criteria(self) -> Dict[str, Dict]:
        """Load diagnostic criteria for medical conditions"""
        return {
            "myocardial_infarction": {
                "major_criteria": ["elevated_troponin", "ecg_changes", "chest_pain"],
                "minor_criteria": ["risk_factors", "age", "family_history"],
                "required_major": 2,
                "required_minor": 1
            },
            "diabetes_mellitus_type2": {
                "major_criteria": ["hba1c_>=6.5", "fasting_glucose_>=126", "ogtt_>=200"],
                "minor_criteria": ["symptoms", "risk_factors"],
                "required_major": 1,
                "required_minor": 0
            }
        }
    
    def forward(self, 
                patient_data: torch.Tensor, 
                attention_mask: torch.Tensor,
                medical_concepts: torch.Tensor) -> Dict[str, torch.Tensor]:
        """
        Forward pass through diagnostic reasoning engine
        
        Args:
            patient_data: Encoded patient information
            attention_mask: Attention mask for patient data
            medical_concepts: Medical concept embeddings
            
        Returns:
            Diagnostic reasoning outputs
        """
        # Encode patient data through language model
        lm_outputs = self.language_model.transformer(
            input_ids=patient_data,
            attention_mask=attention_mask
        )
        patient_embeddings = lm_outputs.last_hidden_state
        
        # Get medical knowledge embeddings
        knowledge_embeddings = self.medical_knowledge_embedder(medical_concepts)
        
        # Combine patient data with medical knowledge
        combined_embeddings = torch.cat([patient_embeddings, knowledge_embeddings], dim=1)
        
        # Apply clinical reasoning transformer
        reasoning_output = self.reasoning_transformer(combined_embeddings)
        
        # Generate diagnostic hypotheses
        condition_representations = self.condition_encoder(reasoning_output)
        
        # Score diagnostic confidence
        confidence_scores = self.confidence_scorer(
            torch.cat([condition_representations.mean(dim=1), patient_embeddings.mean(dim=1)], dim=-1)
        )
        
        # Classify evidence strength
        evidence_scores = self.evidence_classifier(condition_representations.mean(dim=1))
        
        # Stratify risk levels
        risk_scores = self.risk_stratifier(condition_representations.mean(dim=1))
        
        return {
            'diagnostic_embeddings': condition_representations,
            'confidence_scores': confidence_scores,
            'evidence_scores': evidence_scores,
            'risk_scores': risk_scores,
            'reasoning_attention': reasoning_output
        }
    
    def generate_differential_diagnosis(self, 
                                      patient_text: str,
                                      max_diagnoses: int = 5) -> List[DiagnosticHypothesis]:
        """
        Generate ranked differential diagnosis list
        
        Args:
            patient_text: Clinical presentation text
            max_diagnoses: Maximum number of diagnoses to return
            
        Returns:
            List of diagnostic hypotheses ranked by confidence
        """
        # Tokenize patient presentation
        inputs = self.tokenizer(
            patient_text,
            return_tensors="pt",
            truncation=True,
            padding=True,
            max_length=512
        )
        
        # Extract clinical features
        clinical_features = self.extract_clinical_features(patient_text)
        
        # Generate medical concept embeddings
        medical_concepts = torch.randint(0, 10000, (1, 50))  # Simulate concept IDs
        
        # Forward pass
        with torch.no_grad():
            outputs = self.forward(
                inputs['input_ids'],
                inputs['attention_mask'],
                medical_concepts
            )
        
        # Generate diagnostic hypotheses
        hypotheses = []
        
        # Analyze each potential condition
        for condition, condition_data in self.medical_conditions.items():
            # Calculate condition match score
            match_score = self.calculate_condition_match(clinical_features, condition_data)
            
            # Generate supporting evidence
            evidence = self.generate_supporting_evidence(clinical_features, condition_data)
            
            # Determine urgency level
            urgency = self.determine_urgency(condition_data, match_score)
            
            # Create diagnostic hypothesis
            hypothesis = DiagnosticHypothesis(
                condition=condition.replace("_", " ").title(),
                confidence_score=match_score,
                supporting_evidence=evidence,
                risk_factors=self.identify_risk_factors(clinical_features, condition_data),
                recommended_tests=self.recommend_tests(condition_data),
                urgency_level=urgency,
                differential_rank=0  # Will be set after sorting
            )
            
            hypotheses.append(hypothesis)
        
        # Sort by confidence and assign ranks
        hypotheses.sort(key=lambda x: x.confidence_score, reverse=True)
        for i, hypothesis in enumerate(hypotheses[:max_diagnoses]):
            hypothesis.differential_rank = i + 1
        
        return hypotheses[:max_diagnoses]
    
    def extract_clinical_features(self, text: str) -> Dict[str, List[str]]:
        """Extract clinical features from patient text"""
        features = {
            'symptoms': [],
            'vital_signs': [],
            'lab_values': [],
            'medications': [],
            'history': []
        }
        
        # Symptom extraction patterns
        symptom_patterns = [
            r'(?:patient reports|presents with|complains of|experiences)\s+([^.]+)',
            r'(?:symptoms include|symptoms:)\s+([^.]+)',
            r'(?:pain|discomfort|aching)\s+(?:in|at|over)\s+([^.]+)'
        ]
        
        # Vital signs patterns
        vital_patterns = [
            r'(?:bp|blood pressure):\s*(\d+/\d+)',
            r'(?:hr|heart rate):\s*(\d+)',
            r'(?:temp|temperature):\s*(\d+\.?\d*)',
            r'(?:rr|respiratory rate):\s*(\d+)',
            r'(?:o2 sat|oxygen saturation):\s*(\d+)%?'
        ]
        
        # Lab value patterns
        lab_patterns = [
            r'(?:glucose|blood sugar):\s*(\d+\.?\d*)',
            r'(?:hemoglobin|hgb):\s*(\d+\.?\d*)',
            r'(?:wbc|white blood cell):\s*(\d+\.?\d*)',
            r'(?:creatinine):\s*(\d+\.?\d*)',
            r'(?:troponin):\s*(\d+\.?\d*)'
        ]
        
        text_lower = text.lower()
        
        # Extract symptoms
        for pattern in symptom_patterns:
            matches = re.finditer(pattern, text_lower)
            for match in matches:
                features['symptoms'].append(match.group(1).strip())
        
        # Extract vital signs
        for pattern in vital_patterns:
            matches = re.finditer(pattern, text_lower)
            for match in matches:
                features['vital_signs'].append(match.group(0))
        
        # Extract lab values
        for pattern in lab_patterns:
            matches = re.finditer(pattern, text_lower)
            for match in matches:
                features['lab_values'].append(match.group(0))
        
        return features
    
    def calculate_condition_match(self, features: Dict, condition_data: Dict) -> float:
        """Calculate how well features match a medical condition"""
        score = 0.0
        total_weight = 0.0
        
        # Check symptom matches
        feature_symptoms = " ".join(features.get('symptoms', [])).lower()
        for symptom in condition_data.get('key_symptoms', []):
            weight = 0.3
            if symptom.lower() in feature_symptoms:
                score += weight
            total_weight += weight
        
        # Check lab value matches
        feature_labs = " ".join(features.get('lab_values', [])).lower()
        for lab in condition_data.get('key_labs', []):
            weight = 0.25
            if lab.lower() in feature_labs:
                score += weight
            total_weight += weight
        
        # Check for red flags
        all_features = " ".join([
            " ".join(features.get('symptoms', [])),
            " ".join(features.get('vital_signs', [])),
            " ".join(features.get('lab_values', []))
        ]).lower()
        
        for red_flag in condition_data.get('red_flags', []):
            weight = 0.45
            if red_flag.lower() in all_features:
                score += weight
            total_weight += weight
        
        return score / total_weight if total_weight > 0 else 0.0
    
    def generate_supporting_evidence(self, features: Dict, condition_data: Dict) -> List[str]:
        """Generate supporting evidence for a diagnosis"""
        evidence = []
        
        # Symptom evidence
        feature_symptoms = " ".join(features.get('symptoms', [])).lower()
        for symptom in condition_data.get('key_symptoms', []):
            if symptom.lower() in feature_symptoms:
                evidence.append(f"Patient presents with {symptom}")
        
        # Lab evidence
        feature_labs = " ".join(features.get('lab_values', [])).lower()
        for lab in condition_data.get('key_labs', []):
            if lab.lower() in feature_labs:
                evidence.append(f"Laboratory findings consistent with elevated {lab}")
        
        # Clinical category evidence
        if condition_data.get('category'):
            evidence.append(f"Clinical presentation consistent with {condition_data['category']} pathology")
        
        return evidence[:5]  # Limit to top 5 pieces of evidence
    
    def identify_risk_factors(self, features: Dict, condition_data: Dict) -> List[str]:
        """Identify risk factors present in the case"""
        risk_factors = []
        
        # Common risk factors by condition type
        risk_factor_mapping = {
            "cardiovascular": ["hypertension", "diabetes", "smoking", "age", "family history"],
            "respiratory": ["smoking", "copd", "asthma", "environmental exposure"],
            "gastrointestinal": ["inflammatory bowel disease", "family history", "diet"],
            "endocrine": ["obesity", "family history", "sedentary lifestyle"],
            "renal": ["diabetes", "hypertension", "nsaid use"]
        }
        
        category = condition_data.get('category', '')
        potential_risks = risk_factor_mapping.get(category, [])
        
        # Check for mentions of risk factors in features
        all_text = " ".join([
            " ".join(features.get('symptoms', [])),
            " ".join(features.get('history', []))
        ]).lower()
        
        for risk in potential_risks:
            if risk.lower() in all_text:
                risk_factors.append(risk.title())
        
        return risk_factors[:3]  # Limit to top 3 risk factors
    
    def recommend_tests(self, condition_data: Dict) -> List[str]:
        """Recommend diagnostic tests based on condition"""
        tests = []
        
        # Add lab tests
        for lab in condition_data.get('key_labs', []):
            tests.append(lab.upper())
        
        # Add category-specific tests
        category_tests = {
            "cardiovascular": ["ECG", "Echocardiogram", "Stress Test"],
            "respiratory": ["Chest X-ray", "CT Chest", "Pulmonary Function Tests"],
            "gastrointestinal": ["CT Abdomen", "Ultrasound", "Endoscopy"],
            "renal": ["Urinalysis", "Renal Ultrasound", "24-hour Urine"],
            "endocrine": ["Glucose Tolerance Test", "Thyroid Function", "HbA1c"]
        }
        
        category = condition_data.get('category', '')
        if category in category_tests:
            tests.extend(category_tests[category][:2])
        
        return list(set(tests))[:5]  # Remove duplicates and limit to 5
    
    def determine_urgency(self, condition_data: Dict, match_score: float) -> str:
        """Determine clinical urgency level"""
        severity = condition_data.get('severity', 'moderate')
        
        if severity == 'critical' or match_score > 0.8:
            return 'immediate'
        elif severity == 'urgent' or match_score > 0.6:
            return 'urgent'
        elif severity == 'moderate' or match_score > 0.4:
            return 'semi_urgent'
        else:
            return 'non_urgent'

def initialize_diagnostic_engine() -> VibeyDiagnosticReasoningEngine:
    """Initialize the VibeyBot diagnostic reasoning engine"""
    engine = VibeyDiagnosticReasoningEngine()
    
    logger.info("VibeyBot Diagnostic Reasoning Engine initialized successfully")
    logger.info(f"Loaded {len(engine.medical_conditions)} medical conditions")
    logger.info(f"Model parameters: {sum(p.numel() for p in engine.parameters()):,}")
    
    return engine

if __name__ == "__main__":
    # Initialize diagnostic engine
    engine = initialize_diagnostic_engine()
    
    # Example diagnostic reasoning
    sample_case = """
    68-year-old male presents with severe chest pain radiating to left arm.
    Pain started 2 hours ago while mowing lawn. Associated with diaphoresis and nausea.
    BP: 160/95, HR: 110, Temp: 98.6F, RR: 20, O2 Sat: 96%
    Past medical history: Hypertension, diabetes, smoking
    """
    
    diagnoses = engine.generate_differential_diagnosis(sample_case)
    
    logger.info(f"Generated {len(diagnoses)} differential diagnoses")
    for dx in diagnoses:
        logger.info(f"#{dx.differential_rank}: {dx.condition} (confidence: {dx.confidence_score:.3f})")